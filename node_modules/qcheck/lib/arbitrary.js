"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Arbitrary = void 0;
const ex = require("wiinuk-extensions");
const random_1 = require("./random");
const uncheckedDiscriminatedArbitrary = (arbitrary, is) => {
    return new UncheckedDiscriminatedArbitrary(arbitrary, is);
};
class UncheckedDiscriminatedArbitrary {
    constructor(_arbitrary, _is) {
        this._arbitrary = _arbitrary;
        this._is = _is;
    }
    generate(random, size) { return this._arbitrary.generate(random, size); }
    shrink(value) { return this._arbitrary.shrink(value); }
    is(value) { return this._is(value); }
}
var Arbitrary;
(function (Arbitrary) {
    function nullable(arbitrary) {
        return sum([
            pure(null),
            uncheckedDiscriminatedArbitrary(arbitrary, (x) => x !== null),
        ]);
    }
    Arbitrary.nullable = nullable;
    function optional(arbitrary) {
        return sum([
            pure(void 0),
            uncheckedDiscriminatedArbitrary(arbitrary, (x) => x !== void 0),
        ]);
    }
    Arbitrary.optional = optional;
    function sample(arbitrary, { count = 100, initialSize = 0, delta = 2, seed = (Date.now() >>> 0) } = {}) {
        const xs = [];
        const r = new random_1.Random(seed);
        for (let s = initialSize, i = 0; i < count; i++, s += delta) {
            xs[i] = arbitrary.generate(r, s);
        }
        return xs;
    }
    Arbitrary.sample = sample;
    class Map {
        constructor(_arbitrary, _to, _from) {
            this._arbitrary = _arbitrary;
            this._to = _to;
            this._from = _from;
        }
        generate(r, n) { return this._to(this._arbitrary.generate(r, n)); }
        *shrink(value) {
            const to = this._to;
            for (const v2 of this._arbitrary.shrink(this._from(value))) {
                yield to(v2);
            }
        }
    }
    function map(arbitrary, convertTo, convertFrom) {
        return new Map(arbitrary, convertTo, convertFrom);
    }
    Arbitrary.map = map;
    function mapExtend(arbitrary, convertTo) {
        return new Map(arbitrary, convertTo, x => x);
    }
    Arbitrary.mapExtend = mapExtend;
    class Filter {
        constructor(_arbitrary, _predicate) {
            this._arbitrary = _arbitrary;
            this._predicate = _predicate;
        }
        generate(random, size) {
            const { _arbitrary: arb, _predicate: pred } = this;
            while (true) {
                const x = arb.generate(random, size);
                if (pred(x)) {
                    return x;
                }
            }
        }
        *shrink(value) {
            const predicate = this._predicate;
            for (const x of this._arbitrary.shrink(value)) {
                if (predicate(x)) {
                    yield x;
                }
            }
        }
    }
    function filter(arbitrary, predicate) {
        return new Filter(arbitrary, predicate);
    }
    Arbitrary.filter = filter;
    class Pure {
        constructor(_value) {
            this._value = _value;
        }
        is(value) {
            return value === this._value;
        }
        generate() { return this._value; }
        *shrink() { }
    }
    function pure(value) { return new Pure(value); }
    Arbitrary.pure = pure;
    class Elements {
        constructor(_values) {
            this._values = _values;
        }
        generate(r) {
            const vs = this._values;
            return vs[(r.next() * vs.length) | 0];
        }
        *shrink(value) {
            const vs = this._values;
            for (let i = 0; i < vs.length; i++) {
                if (vs[i] === value) {
                    for (let j = i - 1; 0 <= j; j--) {
                        yield vs[j];
                    }
                    return;
                }
            }
        }
    }
    function elements(values) {
        return new Elements(values);
    }
    Arbitrary.elements = elements;
    let CodePoint;
    (function (CodePoint) {
        function category(c) {
            if (c <= 127 /* AsciiMax */) {
                if (97 /* a */ <= c && c <= 122 /* z */) {
                    return 0 /* AsciiLower */;
                }
                if (65 /* A */ <= c && c <= 90 /* Z */) {
                    return 1 /* AsciiUpper */;
                }
                return 3 /* AsciiWithoutLetterOrNumber */;
            }
            if (c <= 255 /* Latin1Max */) {
                return 5 /* UnicodeWithoutLatin1 */;
            }
            return 5 /* UnicodeWithoutLatin1 */;
        }
        CodePoint.category = category;
    })(CodePoint = Arbitrary.CodePoint || (Arbitrary.CodePoint = {}));
    function* shrinkInteger(n) {
        if (n === 0) {
            return;
        }
        yield n - Math.sign(n);
        yield (n / 2) | 0;
        yield 0;
    }
    Arbitrary.number = {
        generate(r, n) {
            n = n | 0;
            const precision = 9999999999999;
            return Math.trunc(r.range(-n * precision, n * precision)) / Math.trunc(r.range(1, precision));
        },
        *shrink(x) {
            if (x < 0) {
                yield -x;
            }
            yield* shrinkInteger(Math.trunc(x));
        }
    };
    Arbitrary.int32 = {
        generate(r, size) { return r.range(-size, size) | 0; },
        shrink(x) { return shrinkInteger(x | 0); }
    };
    Arbitrary.codePoint = {
        generate(r) {
            return (r.next() < 0.5) ? (r.range(0 /* Min */, 127 /* AsciiMax */) | 0) : (r.range(0 /* Min */, 255 /* Latin1Max */) | 0);
        },
        // a-z < A-Z < 0-9 < (\u0000...\u007F) < (\u0080..\u00FF) < ()
        *shrink(x) {
            function* chars(c) {
                yield Math.max(0 /* Min */, c - 1);
                yield (c / 2) | 0;
                yield 32 /* " " */;
                yield 10 /* "\n" */;
                yield 48 /* _0 */;
                yield 97 /* a */;
            }
            const c = Math.max(0 /* Min */, Math.min(1114111 /* Max */, x | 0));
            const cat = CodePoint.category(c);
            for (var c2 of chars(c)) {
                const cat2 = CodePoint.category(c2);
                if (cat2 < cat || (cat2 === cat && c2 < c)) {
                    yield c2;
                }
            }
        }
    };
    class ArrayMinMaxArbitrary {
        constructor(_arbitrary, _minLength) {
            this._arbitrary = _arbitrary;
            this._minLength = _minLength;
        }
        generate(r, size) {
            let xs = [];
            const count = Math.max(this._minLength, r.range(0, size) | 0);
            const arb = this._arbitrary;
            for (let i = 0; i < count; i++) {
                xs[i] = arb.generate(r, size);
            }
            return xs;
        }
        *shrink(xs) {
            if (xs.length === 0 || xs.length <= this._minLength) {
                return;
            }
            // [1, 2, 3, 4]
            // => [1, 2]
            //   => [0, 2]
            //   => [1, 1]
            //   => [1, 0]
            // => [1]
            //   => [0]
            // => []
            const arb = this._arbitrary;
            for (let i = (xs.length / 2) | 0; this._minLength <= i; i = (i / 2) | 0) {
                const xs2 = xs.slice(0, i);
                yield xs2;
                for (let j = 0; j < i; j++) {
                    for (const x of arb.shrink(xs[j])) {
                        const xs3 = xs2.slice();
                        xs3[j] = x;
                        yield xs3;
                    }
                }
            }
        }
    }
    function array(arbitrary, { min = 0 } = {}) { return new ArrayMinMaxArbitrary(arbitrary, min); }
    Arbitrary.array = array;
    const charArray = Arbitrary.array(Arbitrary.codePoint);
    Arbitrary.string = {
        generate(r, size) { return String.fromCodePoint(...charArray.generate(r, size)); },
        *shrink(xs) {
            for (const cs of charArray.shrink(ex.String.codePoints(xs))) {
                yield String.fromCodePoint(...cs);
            }
        }
    };
    class Interface {
        constructor(_arbitraryMap) {
            this._arbitraryMap = _arbitraryMap;
            this._keys = Object.keys(_arbitraryMap).sort();
        }
        generate(r, size) {
            const arbs = this._arbitraryMap;
            const result = Object.create(arbs);
            for (const k of this._keys) {
                result[k] = arbs[k].generate(r, size);
            }
            return result;
        }
        *shrink(xs) {
            for (const key of this._keys) {
                for (const x of this._arbitraryMap[key].shrink(xs[key])) {
                    yield Object.assign({}, xs, { [key]: x });
                }
            }
        }
    }
    function interface_(arbitraryMap) {
        return new Interface(arbitraryMap);
    }
    Arbitrary.interface_ = interface_;
    class Sum {
        constructor(_arbitraries) {
            this._arbitraries = _arbitraries;
        }
        generate(r, size) {
            const arbs = this._arbitraries;
            return arbs[(r.next() * arbs.length) | 0].generate(r, size);
        }
        *shrink(value) {
            for (const arb of this._arbitraries) {
                if (arb.is(value)) {
                    yield* arb.shrink(value);
                }
            }
        }
    }
    class Tuple {
        constructor(_arbitraries) {
            this._arbitraries = _arbitraries;
        }
        generate(r, n) {
            return this._arbitraries.map(arb => arb.generate(r, n));
        }
        *shrink(tuple) {
            const arbs = this._arbitraries;
            if (tuple.length !== arbs.length) {
                return;
            }
            for (let i = 0; i < arbs.length; i++) {
                for (const v2 of arbs[i].shrink(tuple[i])) {
                    const tuple2 = tuple.slice();
                    tuple2[i] = v2;
                    yield tuple2;
                }
            }
        }
    }
    function tuple(arbitraries) {
        return new Tuple(arbitraries);
    }
    Arbitrary.tuple = tuple;
    function sum(arbitraries) {
        return new Sum(arbitraries);
    }
    Arbitrary.sum = sum;
})(Arbitrary = exports.Arbitrary || (exports.Arbitrary = {}));
//# sourceMappingURL=arbitrary.js.map