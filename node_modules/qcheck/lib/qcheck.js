"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.forwardDeclaration = exports.sum = exports.tuple = exports.interface_ = exports.string = exports.array = exports.codePoint = exports.int32 = exports.number = exports.elements = exports.pure = exports.fromArbitrary = exports.Config = exports.Runner = exports.TestResult = exports.Exception = exports.Success = exports.Failure = exports.ResultBase = void 0;
const random_1 = require("./random");
const arbitrary_1 = require("./arbitrary");
__exportStar(require("./random"), exports);
__exportStar(require("./arbitrary"), exports);
var Show;
(function (Show) {
    Show.any = {
        stringify(value) { return String(value); }
    };
})(Show || (Show = {}));
class ResultBase {
    constructor(value, labels) {
        this.value = value;
        this.labels = labels;
    }
}
exports.ResultBase = ResultBase;
class Failure extends ResultBase {
    constructor() {
        super(...arguments);
        this._failure = null;
        this.type = "Failure";
    }
}
exports.Failure = Failure;
class Success extends ResultBase {
    constructor() {
        super(...arguments);
        this._success = null;
        this.type = "Success";
    }
}
exports.Success = Success;
class Exception extends ResultBase {
    constructor(error, value, labels) {
        super(value, labels);
        this.error = error;
        this._exception = null;
        this.type = "Exception";
    }
}
exports.Exception = Exception;
var Result;
(function (Result) {
    function failure({ value, labels }) {
        return new Failure(value, labels);
    }
    Result.failure = failure;
    function success({ value, labels }) {
        return new Success(value, labels);
    }
    Result.success = success;
    function exception(error, { value, labels }) {
        return new Exception(error, value, labels);
    }
    Result.exception = exception;
})(Result || (Result = {}));
var TestResult;
(function (TestResult) {
    function testFailure(args) {
        return Object.assign(Object.assign({}, args), { type: "Failure" });
    }
    TestResult.testFailure = testFailure;
    function testSuccess(args) {
        return Object.assign(Object.assign({}, args), { type: "Success" });
    }
    TestResult.testSuccess = testSuccess;
})(TestResult = exports.TestResult || (exports.TestResult = {}));
var Runner;
(function (Runner) {
    const printOnFinish = (result, log) => {
        if (result.type === "Success") {
            return log(`Ok passed ${result.testCount} tests.`);
        }
        const { show, testCount, shrinkCount, seed, originalFail, minFail } = result;
        log(`Falsifiable, after ${testCount} tests (${shrinkCount} shrink) (seed: ${seed}):`);
        log(`Original: ${show.stringify(originalFail)}`);
        log(`Shrunk: ${show.stringify(minFail)}`);
        if (result.type === "Exception") {
            log(`with exception: ${result.error}`);
        }
    };
    function fromFunction(log) {
        return {
            onShrink(shrinkCount, maxValue, value) {
                log(`shrink[${shrinkCount}]: ${maxValue} => ${value}`);
            },
            onTest(testCount, currentValue) {
                log(`${testCount}: ${currentValue}`);
            },
            onFinish(result) {
                printOnFinish(result, log);
            }
        };
    }
    Runner.fromFunction = fromFunction;
    Runner.console = fromFunction(global.console.log);
    Runner.throwOnFailure = {
        onShrink() { },
        onTest() { },
        onFinish(result) {
            if (result.type === "Success") {
                return;
            }
            throw new (class TestFailureError extends Error {
                constructor() {
                    let message = "";
                    printOnFinish(result, line => message += line + "\n");
                    super(message);
                }
                get testResult() { return result; }
            })();
        }
    };
})(Runner = exports.Runner || (exports.Runner = {}));
var Config;
(function (Config) {
    Config.defaultValue = Object.freeze({
        maxTest: 100,
        startSize: 1,
        endSize: 100,
    });
})(Config = exports.Config || (exports.Config = {}));
function currentSize(startSize, endSize, maxTest, index) {
    return startSize + (endSize - startSize) * ((index + 1) / maxTest) | 0;
}
function runTest({ test, show }, value) {
    try {
        const r = test(value);
        if (r instanceof Failure || r instanceof Success || r instanceof Exception) {
            return r;
        }
        if (r === false) {
            return Result.failure({ value: show.stringify(value), labels: null });
        }
        return Result.success({ value: show.stringify(value), labels: null });
    }
    catch (e) {
        return Result.exception(e, { value: show.stringify(value), labels: null });
    }
}
function findLocalMinFail(state, originalFail) {
    const { runner, arb, seed, show, testCount } = state;
    let shrinkCount = 0;
    let maxFail = originalFail;
    let minFail = maxFail;
    let failCount = 0;
    findMin: while (true) {
        for (const v of arb.shrink(maxFail)) {
            runner.onShrink(shrinkCount, show.stringify(maxFail), show.stringify(v));
            const r = runTest(state, v);
            if (r.type === "Success") {
                if (failCount === 0) {
                    break findMin;
                }
                maxFail = minFail;
                failCount = 0;
                continue findMin;
            }
            else {
                failCount++;
                shrinkCount++;
                minFail = v;
            }
        }
        break findMin;
    }
    return TestResult.testFailure({ shrinkCount, originalFail, minFail, seed, show, testCount });
}
function check(arb, show, test, { seed = random_1.seedOfNow(), maxTest, startSize, endSize, runner = Runner.throwOnFailure } = Config.defaultValue) {
    const random = new random_1.Random(seed), minSize = Math.max(1, startSize), maxSize = Math.max(endSize, minSize);
    for (let testCount = 0; testCount < maxTest; testCount++) {
        const size = currentSize(minSize, maxSize, maxTest, testCount);
        const v = arb.generate(random, size);
        runner.onTest(testCount, show.stringify(v));
        const r = runTest({ arb, show, test, testCount, seed, runner }, v);
        if (r.type === "Success") {
            continue;
        }
        const testResult = findLocalMinFail({ arb, show, test, testCount: testCount + 1, seed, runner }, v);
        runner.onFinish(testResult);
        return testResult;
    }
    return TestResult.testSuccess({ seed, show, testCount: maxTest });
}
class FromArbitrary {
    constructor(_arbitrary, _stringify = Show.any.stringify) {
        this._arbitrary = _arbitrary;
        this._stringify = _stringify;
    }
    sample(options) { return arbitrary_1.Arbitrary.sample(this._arbitrary, options); }
    generate(random, size) { return this._arbitrary.generate(random, size); }
    shrink(value) { return this._arbitrary.shrink(value); }
    check(test, config) { return check(this, this, test, config); }
    array(options) { return array(this, options); }
    readonlyArray(options) { return array(this, options); }
    map(convertTo, convertFrom = x => x) { return fromArbitrary(arbitrary_1.Arbitrary.map(this, convertTo, convertFrom)); }
    filter(predicate) { return fromArbitrary(arbitrary_1.Arbitrary.filter(this, predicate)); }
    nullable() { return fromArbitrary(arbitrary_1.Arbitrary.nullable(this)); }
    optional() { return fromArbitrary(arbitrary_1.Arbitrary.optional(this)); }
    stringify(value) { return this._stringify(value); }
    withPrinter(stringify) { return new FromArbitrary(this._arbitrary, stringify); }
    is(value) {
        return this._arbitrary.is(value);
    }
}
function fromArbitrary(arbitrary) {
    return new FromArbitrary(arbitrary);
}
exports.fromArbitrary = fromArbitrary;
function pure(value) { return fromArbitrary(arbitrary_1.Arbitrary.pure(value)); }
exports.pure = pure;
function elements(value, ...values) { return fromArbitrary(arbitrary_1.Arbitrary.elements([value, ...values])); }
exports.elements = elements;
exports.number = fromArbitrary(arbitrary_1.Arbitrary.number);
exports.int32 = fromArbitrary(arbitrary_1.Arbitrary.int32);
exports.codePoint = fromArbitrary(arbitrary_1.Arbitrary.codePoint);
function array(arbitrary, options) { return fromArbitrary(arbitrary_1.Arbitrary.array(arbitrary, options)); }
exports.array = array;
exports.string = fromArbitrary(arbitrary_1.Arbitrary.string);
function interface_(arbitraryMap) { return fromArbitrary(arbitrary_1.Arbitrary.interface_(arbitraryMap)); }
exports.interface_ = interface_;
function tuple(...arbitraries) {
    return fromArbitrary(arbitrary_1.Arbitrary.tuple(arbitraries));
}
exports.tuple = tuple;
function sum(...arbitraries) {
    return fromArbitrary(arbitrary_1.Arbitrary.sum(arbitraries));
}
exports.sum = sum;
function throwNotInitialized() {
    throw new Error("definition not assigned");
}
class ForwardDeclarationCheckerImpl {
    get definition() { return this; }
    set definition(x) { Object.setPrototypeOf(this, x); }
    check() { return throwNotInitialized(); }
    array1() { return throwNotInitialized(); }
    array2() { return throwNotInitialized(); }
    array() { return throwNotInitialized(); }
    readonlyArray1() { return throwNotInitialized(); }
    readonlyArray2() { return throwNotInitialized(); }
    readonlyArray() { return throwNotInitialized(); }
    sample() { return throwNotInitialized(); }
    mapExtend() { return throwNotInitialized(); }
    map() { return throwNotInitialized(); }
    filter() { return throwNotInitialized(); }
    nullable() { return throwNotInitialized(); }
    optional() { return throwNotInitialized(); }
    generate() { return throwNotInitialized(); }
    shrink() { return throwNotInitialized(); }
    stringify() { return throwNotInitialized(); }
    withPrinter() { return throwNotInitialized(); }
}
function forwardDeclaration() {
    return new ForwardDeclarationCheckerImpl();
}
exports.forwardDeclaration = forwardDeclaration;
//# sourceMappingURL=qcheck.js.map