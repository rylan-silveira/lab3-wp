import { Nullable, Optional, primitive, Int32, CodePoint } from "wiinuk-extensions";
import { Arbitrary, SampleOptions, ArrayArbitraryOptions, DiscriminatedArbitrary, Discriminator } from "./arbitrary";
export * from "./random";
export * from "./arbitrary";
export interface Show<T> {
    stringify(value: T): string;
}
export declare class ResultBase {
    readonly value: string;
    readonly labels: Set<string> | null;
    constructor(value: string, labels: Set<string> | null);
}
export declare class Failure extends ResultBase {
    protected readonly _failure: null;
    readonly type = "Failure";
}
export declare class Success extends ResultBase {
    protected readonly _success: null;
    readonly type = "Success";
}
export declare class Exception extends ResultBase {
    readonly error: any;
    protected readonly _exception: null;
    readonly type = "Exception";
    constructor(error: any, value: string, labels: Set<string> | null);
}
export interface TestResultBase<T> {
    readonly show: Show<T>;
    readonly seed: number;
    readonly testCount: number;
}
export interface TestFailureArgs<T> extends TestResultBase<T> {
    readonly shrinkCount: number;
    readonly originalFail: T;
    readonly minFail: T;
}
export interface TestFailure<T> extends TestFailureArgs<T> {
    readonly type: "Failure";
}
export interface TestFailureWithExceptionArgs<T> extends TestFailureArgs<T> {
    readonly error: any;
}
export interface TestFailureWithException<T> extends TestFailureWithExceptionArgs<T> {
    readonly type: "Exception";
}
export interface TestSuccessArgs<T> extends TestResultBase<T> {
}
export interface TestSuccess<T> extends TestSuccessArgs<T> {
    readonly type: "Success";
}
export declare type TestResult<T> = TestFailure<T> | TestFailureWithException<T> | TestSuccess<T>;
export declare namespace TestResult {
    function testFailure<T>(args: TestFailureArgs<T>): TestFailure<T>;
    function testSuccess<T>(args: TestSuccessArgs<T>): TestSuccess<T>;
}
export interface Runner {
    onShrink(shrinkCount: number, maxValue: string, currentValue: string): void;
    onTest(testCount: number, currentValue: string): void;
    onFinish<T>(result: TestResult<T>): void;
}
export declare namespace Runner {
    function fromFunction(log: (message: string) => void): Runner;
    const console: Runner;
    const throwOnFailure: Runner;
}
export interface Config {
    readonly seed?: number;
    readonly maxTest: number;
    readonly startSize: number;
    readonly endSize: number;
    readonly runner?: Runner;
}
export declare namespace Config {
    const defaultValue: Config;
}
export interface Checker<T> extends Arbitrary<T>, Show<T> {
    sample(options?: SampleOptions): T[];
    check(test: (value: T) => any, config?: Config): TestResult<T>;
    array(options: {
        readonly min: 1;
    }): Checker<[T, ...T[]]>;
    array(options: {
        readonly min: 2;
    }): Checker<[T, T, ...T[]]>;
    array(options?: {
        readonly min?: number;
    }): Checker<T[]>;
    readonlyArray(options: {
        readonly min: 1;
    }): Checker<readonly [T, ...T[]]>;
    readonlyArray(options: {
        readonly min: 2;
    }): Checker<readonly [T, T, ...T[]]>;
    readonlyArray(options?: {
        readonly min?: number;
    }): Checker<readonly T[]>;
    map<U extends T>(convertTo: (value: T) => U): Checker<U>;
    map<U>(convertTo: (value: T) => U, convertFrom: (value: U) => T): Checker<U>;
    filter(predicate: (value: T) => boolean): Checker<T>;
    nullable<A extends {} | undefined>(this: Checker<A>): Checker<Nullable<A>>;
    optional<A extends {} | null>(this: Checker<A>): Checker<Optional<A>>;
    withPrinter(stringify: (value: T) => string): Checker<T>;
}
export interface DiscriminatedChecker<TOverall, T extends TOverall> extends Checker<T>, Discriminator<TOverall, T> {
}
export declare function fromArbitrary<TOverall, T extends TOverall>(arbitrary: DiscriminatedArbitrary<TOverall, T>): DiscriminatedChecker<TOverall, T>;
export declare function fromArbitrary<T>(arbitrary: Arbitrary<T>): Checker<T>;
export declare function pure<T extends null | undefined | string | number | boolean>(value: T): DiscriminatedChecker<unknown, T>;
export declare function pure<T>(value: T): Checker<T>;
export declare function elements<T extends primitive>(value: T, ...values: T[]): Checker<T>;
export declare const number: Checker<number>;
export declare const int32: Checker<Int32>;
export declare const codePoint: Checker<CodePoint>;
export declare function array<T>(arbitrary: Arbitrary<T>, options: ArrayArbitraryOptions<1>): Checker<[T, ...T[]]>;
export declare function array<T>(arbitrary: Arbitrary<T>, options: ArrayArbitraryOptions<2>): Checker<[T, T, ...T[]]>;
export declare function array<T>(arbitrary: Arbitrary<T>, options?: Partial<ArrayArbitraryOptions<number>>): Checker<T[]>;
export declare const string: Checker<string>;
export declare function interface_<T>(arbitraryMap: {
    [P in keyof T]: Arbitrary<T[P]>;
}): Checker<T>;
export declare function tuple<TArbs extends Arbitrary<any>[]>(...arbitraries: TArbs): Checker<{
    [k in keyof TArbs]: TArbs[k] extends Arbitrary<infer t> ? t : never;
}>;
export declare function sum<TArbs extends [DiscriminatedArbitrary<any, any>, ...DiscriminatedArbitrary<any, any>[]]>(...arbitraries: TArbs): Checker<{
    [k in keyof TArbs]: TArbs[k] extends DiscriminatedArbitrary<any, infer t> ? t : never;
}[number]>;
export interface ForwardDeclarationChecker<T> extends Checker<T> {
    definition: Checker<T>;
}
export declare function forwardDeclaration<T>(): ForwardDeclarationChecker<T>;
