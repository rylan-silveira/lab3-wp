import { Int32, primitive, CodePoint as C } from "wiinuk-extensions";
import { Random } from "./random";
export interface SampleOptions {
    count?: number;
    initialSize?: number;
    delta?: number;
    seed?: number;
}
export interface ArrayArbitraryOptions<Min extends number> {
    readonly min: Min;
}
export interface Arbitrary<T> {
    generate(random: Random, size: Int32): T;
    shrink(value: T): Iterable<T>;
}
export interface Discriminator<TOverall, T extends TOverall> {
    is(value: TOverall): value is T;
}
export interface DiscriminatedArbitrary<TOverall, T extends TOverall> extends Arbitrary<T>, Discriminator<TOverall, T> {
}
export declare namespace Arbitrary {
    function nullable<T extends {} | undefined>(arbitrary: Arbitrary<T>): Arbitrary<T | null>;
    function optional<T extends {} | null>(arbitrary: Arbitrary<T>): Arbitrary<T | undefined>;
    function sample<T>(arbitrary: Arbitrary<T>, { count, initialSize, delta, seed }?: SampleOptions): T[];
    function map<T, U>(arbitrary: Arbitrary<T>, convertTo: (x: T) => U, convertFrom: (x: U) => T): Arbitrary<U>;
    function mapExtend<T, U extends T>(arbitrary: Arbitrary<T>, convertTo: (x: T) => U): Arbitrary<U>;
    function filter<T>(arbitrary: Arbitrary<T>, predicate: (value: T) => boolean): Arbitrary<T>;
    function pure<T extends primitive>(value: T): DiscriminatedArbitrary<unknown, T>;
    function pure<T>(value: T): Arbitrary<T>;
    function elements<T extends primitive>(values: readonly [T, ...T[]]): Arbitrary<T>;
    namespace CodePoint {
        const enum Category {
            AsciiLower = 0,
            AsciiUpper = 1,
            AsciiNumber = 2,
            AsciiWithoutLetterOrNumber = 3,
            Latin1WithoutAscii = 4,
            UnicodeWithoutLatin1 = 5
        }
        function category(c: C): Category.AsciiLower | Category.AsciiUpper | Category.AsciiWithoutLetterOrNumber | Category.UnicodeWithoutLatin1;
    }
    const number: Arbitrary<number>;
    const int32: Arbitrary<Int32>;
    const codePoint: Arbitrary<C>;
    function array<T>(arbitrary: Arbitrary<T>, options: ArrayArbitraryOptions<1>): Arbitrary<[T, ...T[]]>;
    function array<T>(arbitrary: Arbitrary<T>, options: ArrayArbitraryOptions<2>): Arbitrary<[T, T, ...T[]]>;
    function array<T>(arbitrary: Arbitrary<T>, options?: Partial<ArrayArbitraryOptions<number>>): Arbitrary<Array<T>>;
    const string: Arbitrary<string>;
    function interface_<T>(arbitraryMap: {
        [P in keyof T]: Arbitrary<T[P]>;
    }): Arbitrary<T>;
    function tuple<TArbs extends readonly Arbitrary<any>[]>(arbitraries: TArbs): Arbitrary<{ -readonly [k in keyof TArbs]: TArbs[k] extends Arbitrary<infer t> ? t : never; }>;
    function sum<TArbs extends readonly [DiscriminatedArbitrary<any, any>, ...DiscriminatedArbitrary<any, any>[]]>(arbitraries: TArbs): Arbitrary<{
        [k in keyof TArbs]: TArbs[k] extends DiscriminatedArbitrary<any, infer t> ? t : never;
    }[number]>;
}
